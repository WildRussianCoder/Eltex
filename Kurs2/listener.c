#include "init.h"


/* Требуется узнать о том, атомарна ли операция записи в очередь.
   Если атомарна, то следует разбить получение сообщения от клиентов
   по потокам. Если эта операция не атомарна, то нет никакого смысла
   разбивать клиентов по потокам, ведь в этом случае мы только потеряем
   на синхронизации записи в очередь сообщений. */



/* sockaddr для прослушивающего TCP-сокета */
struct sockaddr_in addr;

/* Структура с атрибутами очереди сообщений */
struct mq_attr qattr;

int main ()
{
    /* Устанавливаем параметры sockaddr */
    addr.sin_family = AF_INET;
    addr.sin_port = htons ( LISTENER_TCP_PORT );
    addr.sin_addr.s_addr = htonl ( INADDR_ANY );

    /* Открываем созданную очередь сообщений */
    mqd_t q = mq_open(Q_NAME, O_WRONLY);
    if ( q < 0 )
    {
        perror ( "Ошибка открытия очереди сообщений в listener" );
        exit ( -1 );
    }

    /* Создаем прослушивающий сокет */
    int sock = socket ( AF_INET, SOCK_STREAM, 0 );
    if ( sock < 0 )
    {
        perror ( "Ошибка создания сокета в listener" );
        exit ( -1 );
    }

    /* Связываем прослушивающий сокет с портом */
    if ( bind ( sock, ( struct sockaddr* ) &addr, sizeof ( addr ) ) < 0 )
    {
        perror ( "Ошибка связывания сокета в listener" );
        exit ( -1 );
    }

    /* Устанавливаем очередь соединений */
    if ( listen ( sock, CLIENT_Q ) < 0 )
    {
        perror ( "Ошибка создания очереди клиентов в listener" );
        exit ( -1 );
    }

    /* В бесконечном цикле принимаем подключения клиентов, получаем от них сообщения и отключаемся.
       Новые потоки не требуются, т.к. доступ к очереди должен быть синхронным, а следователььно
       никакого выигрыша от распараллеливания мы не получим, а скорее наоборот, только потеряем */
    while ( 1 )
    {
        /* Принимаем подключение клиента */
        int client_sock = accept ( sock, NULL, NULL );

        /* Получаем атрибуты очереди сообщений, чтобы проверить кол-во сообщений в очереди */
        mq_getattr ( q, &qattr );

        /* Если очередь заполнена, то отбрасываем клиента, иначе принимаем от него сообщения */
        if ( qattr.mq_curmsgs == MAX_MSG )
            close ( client_sock );
        else 
        {
            /* Значения получаемые от клиента */
            int t;
            int len;
            char* msg;

            /* Получение времени обработки */
            if ( read (client_sock, &t, sizeof ( t ) ) < 0 )
            {
                perror ( "Ошибка при получении времени от клиента " );
                exit ( -1 );
            }

            /* Получение длины сообщения */
            if ( read ( client_sock, &len, sizeof ( len ) ) < 0 )
            {
                perror ( "Ошибка получения длины от клиента" );
                exit ( -1 );
            }

            /* Выделение памяти под сообщение */
            msg = malloc ( msg );
            if ( msg == NULL )
            {
                perror ( "Ошибка выделения памяти под сообщение" );
                exit ( -1 );
            }

            /* Получение сообщения */
            if ( read ( client_sock, msg, len ) < 0)
            {
                perror ( "Ошибка получения сообщения от клиента" );
                exit ( -1 );
            }

            /* Закрытие соединения с клиентом */
            if ( close ( client_sock ) < 0 )
            {
                perror ( "Ошибка закрытия соединения с клиентом" );
                exit ( -1 );
            }

            /* Запись полученного сообщения в очередь */
            if ( mq_send ( q, msg, len, 0 ) < 0 )
            {
                perror ( "Ошибка записи сообщения в очередь" );
                exit(-1);
            }
        }
    }
}